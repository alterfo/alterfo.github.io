<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Выбор стека технологий (переусложнение) | Блог</title>
    <meta name="generator" content="VuePress 1.9.10">
    
    <meta name="description" content="Это третья статья в цикле &quot;Выбор стека технологий&quot;.

1. Выбор стека технологий (введение и кейсы)
1. Выбор стека технологий (доступность и поддерживаемость)

В первой статье мы ...">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <link rel="preload" href="/assets/css/0.styles.5474d5c3.css" as="style"><link rel="preload" href="/assets/js/app.9a3be13b.js" as="script"><link rel="preload" href="/assets/js/6.6d8d87b4.js" as="script"><link rel="preload" href="/assets/js/51.1210696b.js" as="script"><link rel="prefetch" href="/assets/js/1.22e13cfc.js"><link rel="prefetch" href="/assets/js/10.3067cb1e.js"><link rel="prefetch" href="/assets/js/11.a92f93a9.js"><link rel="prefetch" href="/assets/js/12.dc46fbef.js"><link rel="prefetch" href="/assets/js/13.fcd4802b.js"><link rel="prefetch" href="/assets/js/14.44876c2d.js"><link rel="prefetch" href="/assets/js/15.7937b6ea.js"><link rel="prefetch" href="/assets/js/16.3281a144.js"><link rel="prefetch" href="/assets/js/17.045ae130.js"><link rel="prefetch" href="/assets/js/18.42f27b60.js"><link rel="prefetch" href="/assets/js/19.ac11e6eb.js"><link rel="prefetch" href="/assets/js/2.54b37a65.js"><link rel="prefetch" href="/assets/js/20.21e56f7f.js"><link rel="prefetch" href="/assets/js/21.542083ec.js"><link rel="prefetch" href="/assets/js/22.ff78fbfc.js"><link rel="prefetch" href="/assets/js/23.1dd2f47b.js"><link rel="prefetch" href="/assets/js/24.82dbf54e.js"><link rel="prefetch" href="/assets/js/25.5cfcbf68.js"><link rel="prefetch" href="/assets/js/26.4d499b05.js"><link rel="prefetch" href="/assets/js/27.24c878f1.js"><link rel="prefetch" href="/assets/js/28.86942fc4.js"><link rel="prefetch" href="/assets/js/29.6ef0b457.js"><link rel="prefetch" href="/assets/js/3.d20b0515.js"><link rel="prefetch" href="/assets/js/30.ff6b6200.js"><link rel="prefetch" href="/assets/js/31.72326215.js"><link rel="prefetch" href="/assets/js/32.cecd5f8f.js"><link rel="prefetch" href="/assets/js/33.ac33a1d6.js"><link rel="prefetch" href="/assets/js/34.24869d83.js"><link rel="prefetch" href="/assets/js/35.cdfe83ff.js"><link rel="prefetch" href="/assets/js/36.7843586b.js"><link rel="prefetch" href="/assets/js/37.1ddffe8e.js"><link rel="prefetch" href="/assets/js/38.bcf76a33.js"><link rel="prefetch" href="/assets/js/39.a5a1e4fd.js"><link rel="prefetch" href="/assets/js/4.7346b154.js"><link rel="prefetch" href="/assets/js/40.2242aa28.js"><link rel="prefetch" href="/assets/js/41.de1ec231.js"><link rel="prefetch" href="/assets/js/42.8abaca81.js"><link rel="prefetch" href="/assets/js/43.6d8d44d2.js"><link rel="prefetch" href="/assets/js/44.1943569e.js"><link rel="prefetch" href="/assets/js/45.8eaa1d6b.js"><link rel="prefetch" href="/assets/js/46.a44f32b7.js"><link rel="prefetch" href="/assets/js/47.d213621f.js"><link rel="prefetch" href="/assets/js/48.27cb4b2f.js"><link rel="prefetch" href="/assets/js/49.9dad2ef5.js"><link rel="prefetch" href="/assets/js/5.b0d41900.js"><link rel="prefetch" href="/assets/js/50.94705a8f.js"><link rel="prefetch" href="/assets/js/52.e26258dd.js"><link rel="prefetch" href="/assets/js/53.4ba53d6f.js"><link rel="prefetch" href="/assets/js/54.945f0a92.js"><link rel="prefetch" href="/assets/js/7.d1eea65e.js"><link rel="prefetch" href="/assets/js/vuejs-paginate.9e57b552.js">
    <link rel="stylesheet" href="/assets/css/0.styles.5474d5c3.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><main data-v-4d3dfa27><header id="large-header" class="site-header" data-v-4d3dfa27><canvas id="canvas"></canvas> <div class="animation-toggler top-2"><a href="javascript:void(0)">Включить анимацию!</a></div> <div class="page-title" style="opacity:1;">Выбор стека технологий (переусложнение)</div></header> <div class="content-wrapper" data-v-4d3dfa27><main data-v-4d3dfa27><article><div class="content__default"><p>Это третья статья в цикле &quot;Выбор стека технологий&quot;.</p> <p><a href="/stack-1">1. Выбор стека технологий (введение и кейсы)</a> <a href="/stack-2">1. Выбор стека технологий (доступность и поддерживаемость)</a></p> <p>В первой статье мы определили содержание стека технологий. Это:</p> <ul><li>хранилище данных</li> <li>бэкенд-фреймворк</li> <li>фронтенд-фреймворк</li> <li>системы виртуализации/контейнеризации</li> <li>API</li> <li>DevOps (IaC, мониторинг, логгирование), например, ELK (Elasticsearch, Logstash, Kibana)</li></ul> <p>Во второй статье мы рассмотрели вопрос выбора стека с точки зрения атрибутов качества - доступность и поддерживаемость</p> <p>В этой статье мы посмотрим на вопрос выбора стека ещё шире, глубже и конкретнее.</p> <blockquote><p>Critical thinking is the analysis of available facts, evidence, observations, and arguments to form a judgment.</p> <p>Edward M. Glaser. &quot;<a href="https://www.criticalthinking.org/pages/defining-critical-thinking/766" target="_blank" rel="noopener noreferrer">Defining Critical Thinking<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>&quot;</p></blockquote> <blockquote><p>Критическое мышление — способность человека ставить под сомнение поступающую информацию, включая собственные убеждения.</p> <p>Википедия</p></blockquote> <p>На что не стоит опираться при выборе стека:</p> <ul><li>Личные предпочтения</li> <li>Хайп</li> <li>Советы коллег из других компаний</li> <li>Звездочки на Github-е</li> <li>Опросы на Stackoverflow</li></ul> <p>На что стоит делать упор:</p> <ul><li>Личный опыт успешных проектов</li> <li>Доказанный опыт успешных проектов других компаний</li> <li>Простоту и удобство использования</li> <li>Наличие прототипов, реализующих задуманное на конкретной технологии</li> <li>Отношение потенциальной пользы от внедрения к трудопотерям на внедрение</li></ul> <p>Список вопросов, на которые стоит ответить при выборе любого решения, не только стека:</p> <ul><li><strong>Как долго эта технология будет жива и пользоваться спросом?</strong> Flash, Pascal, VHS - популярные в прошлом, но забытые сейчас. Нужно брать технологии, у которых впереди в запасе как минимум 10 лет развития.</li> <li><strong>Легко ли обслуживать эту технологию?</strong> &quot;Используя популярный тулсет вы с легкостью найдете специалиста&quot; именно этим руководствовались миллионы проектов которые взяли React в качестве фронтенд-фреймворка. В итоге множество проектов завязли в некачественном коде из-за отсутствия архитектуры. Если вам нужно быстро выйти на рынок, проще всего взять PHP и Vue. Но на долгой дистанции с ними будет много мучений.</li> <li><strong>Какие обременения и накладные расходы у этой технологии?</strong> О выгодах мы задумываемся автоматически. Они ослепляют. Каждая новая технология это +1 человек к команде. Typescript - кто-то должен писать типы, UI Material - кто-то должен читать документацию, Docker - отдельный человек для написания helm-charts и тд.</li> <li><strong>Если это миграция - возможен ли откат, какова цена восстановления в случае неудачи?</strong></li> <li><strong>Если это внедрение нового - какова стоимость внедрения и сроки окупаемости?</strong></li></ul> <p>Помимо всего прочего, важна экспертная оценка реализации проекта. Желательно иметь подробный ресурсный план для каждой технологии, написанный признанным экспертом.</p> <p>Может оказаться, что реализация на Java и React займет год и 100 миллионов, но на Go и Angular - полгода и 20 миллионов. Выбор будет очевиден.</p> <h2 id="пример-переусложнения"><a href="#пример-переусложнения" class="header-anchor">#</a> Пример переусложнения</h2> <p>В этой выдуманной истории огромное количество скрытой иронии, прошу прощения.</p> <p>Итак, представьте, у генерального директора Андрея появилась идея на миллиард, и даже предварительные договоренности о продажах. Он подходит к своему зятю-программисту Алексею и говорит - нужно сделать проект, поможешь?</p> <p>Андрей назначает Алексея CTO (станция техобслуживания) и ждет первых результатов.</p> <p>Алексей, не будучи дураком, начинает мыслить глобально, как настоящий профессионал.</p> <p>Он начинает с Frontend-а. Язык - без вариантов - JavaScript. Точнее, его типизированная ипостась - Typescript. Из статей в интернете он узнает что у Angular очень высокий порог вхождения, Vue имеет слабую поддержку одним человеком, а jQuery уже устарел и выбирает React. Ведь на рынке огромная толпа разработчиков на React и астрономическое количество готовых компонентов для него. К тому же React не ограничивает архитектуру, гибкость инструмента способствует быстрой разработке.</p> <p>Также он узнает что Bootstrap уже не моден и в качестве компонентной библиотеки выбирает Material-UI. А в качестве CSS-фреймворка Tailwind.</p> <p>Также, для фронтенда ему пригодятся Webpack, icomoon и сотня-другая компонентов для реализации задуманного, включая websocket и canvas.</p> <p>Ах да, он чуть не забыл про State-manager, коих уже десятки, он выбирает самый популярный Redux, ведь, чем больше boilerplate-кода, тем стабильнее и надежнее приложение.</p> <p>Итак, на фронтенде - React, Redux, Material-UI, Tailwind, Webpack и много всего остального.</p> <p>Бэкенд - тут Алексей решил не переусложнять, а оставить один язык для всего приложения и на сервере будет запущено приложение на Node.js. Повыбирав из фреймворков (Next.js, Nuxt.js, etc.js...), он решил взять то, что не имеет строгой привязки к фреймворку - Nest.js.</p> <p>База данных - конечно MongoDB, ведь в интернете написано что она очень быстрая и гибкая. Но, на всякий случай, будем использовать ее как реляционную, все сущности будут связаны и лежать в отдельных коллекциях. Рядом будет in-memory cache Redis на случай большой нагрузки.</p> <p>В качестве API Алексей решил сделать прямое соединение через Websocket. Это быстро, модно и просто.</p> <p>Подумав ещё, Алексей решил сразу создать пайплайны CI/CD, и сразу запускать Docker-контейнеры в облако с помощью helm-чартов - в Kubernetes кластер, чтобы иметь возможность горизонтально масштабировать приложение автоматически.</p> <p>А чтобы контейнеров было побольше - для пущей модульности - сразу решил разделить приложение на микросервисы и положить в разные репозитории, общение организовать через Kafka, а базу данных - реплицировать на три ноды, так точно будет работать быстрее.</p> <p>Прошло несколько лет, продукт наконец вышел, рос медленно, но верно и продажи поднялись - продукт получил популярность, даже с такими высокими ценами. Алексей решает набрать команду и нанимает 7 фулл-стэк разработчиков. К этому моменту и в последствии, tailwindcss и material-ui использованы в 10% кода, React-компоненты встречаются и в виде классов, и в функциональном стиле со множеством перегруженных кастомных хуков.</p> <p>А тем временем приложение начинает падать по три раза в день от наплыва пользователей - база данных съедает всю память на самой большой виртуальной машине в облаке потому что деплой в Kubernetes так и не смогли настроить ни подрядчики ни весь отдел разработки, хотя пытались по очереди все. Kafka тоже не поднялась.</p> <p>Также возникают проблемы с уведомлениями - письма не доходят - падают в спам, заказчики не получают вовремя отчеты, а работа идет все медленнее и медленнее из-за количества багов ввиду излишней гибкости фронтенда.</p> <p>Поскольку CTO не разбирался в серверах и у него никогда не было больших проектов, место на диске съели логи, продуктовый сервер был настроен абы как, а доступ к нему был у половины разработчиков в любое время без надзора. Разделения сред тоже не продумали, тестовый сервер оккупировал менеджмент для демонстраций заказчику, ломать его было нельзя, данные мало были похожи на реальные.</p> <p>Наш CTO понимает что пора - пора осуществить задуманное - переехать с MongoDB на RDBMS, например, PostgreSQL, но количество написанных без ORM агрегаций, которыми так славится MongoDB, выглядело неподъемным. Redis не помогал, а больше мешал. Типы были перегруженными, а конвертация данных - повсеместной. В проекте насчитывались тысячи вызовов map и reduce.</p> <p>Плюс, заказчики стали настаивать на том, чтобы приложение работало оффлайн (эту функцию откладывали до последнего, как слишком простую, были задачи поинтереснее, с canvas-ом). И тут выясняется, что нужно загрузить несколько гигабайт информации на устройство пользователя. А при каждом обновлении приложения эти данные стирать, потому что схема изменилась, то есть, писать миграции для State manager-а.</p> <p>Генеральный директор, видя что приложение падает под напором, предлагает самым крупным заказчикам беспрецендентный шаг - ради их же безопасности, компания будет устанавливать приложение на сервера заказчика. Первая установка прошла успешно, вторая тоже, но автоматизировать процесс установки не получается - можно только вручную и особо обученным сотрудником - человеком, разбирающемся в приложении, интеграциях и unix-серверах. Такой стоит недешево.</p> <p>В общем и целом, оверинжиниринг во всей красе - 12 окружений которые нужно обновлять только вручную и только по выходным, плюс множество технологий, которые сильно усложняют общую картину, хотя, казалось бы, призваны решать проблемы.</p> <p>Цена упрощения такого проекта - примерно 10 миллионов рублей. Это выделенная команда для миграции из 6 человек на год работы.</p> <p>Несмотря на то, что проект успел заработать в несколько раз больше - такой огромный технический долг его может потопить.</p> <h2 id="пример-упрощения"><a href="#пример-упрощения" class="header-anchor">#</a> Пример упрощения</h2> <p>В целом, стэк был выбран разумно, но к переусложнению привели другие факторы. Время разобраться.</p> <p>Давайте сначала выпишем ошибки, которые были допущены выше:</p> <ol><li>Использование MongoDB как реляционной базы данных привело к дорогим проблемам производительности</li> <li>Чрезмерная преждевременная оптимизация и решение вымышленных проблем масштабирования привело к потере времени на настройку</li> <li>Назначение CTO малокомпетентного и неопытного человека</li></ol> <p>Исходя из этого, фундамент проекта стоило заложить так:</p> <ul><li>Использовать MongoDB в качестве хранилища, но как NoSQL - так будет проще работать с данными - агрегации все равно запускаются на JavaScript, также будет проще переходить на реляционную базу - запросы будут проще, да и на несколько баз разделить проще</li> <li>Ввести правило оценивать трудозатраты и потенциальную выгоду от реализации фич, таким образом ни функциональность, ни архитектура решения не будут страдать от жажды скорой наживы</li> <li>Начать с самого простого - с монолита, так как очень редко встречаются настолько огромные проекты чтобы вводить микросервисную архитектуру</li> <li>Поставки приложения - в виде образа виртуальной машины, который достаточно просто развернуть в среде заказчика, руками самого заказчика</li> <li>Описать архитектуру проекта в виде 4D и менять по мере необходимости</li> <li>На ранних стадиях ввести мониторинг систем, установить ELK стэк и настроить режим логгирования, бэкапа, управления инцидентами</li> <li>Следовать принципу &quot;проще - лучше&quot;, причем, &quot;так быстрее&quot; - почти всегда плохо и приводит к сложностям</li></ul></div></article></main></div> <footer class="footer" data-v-6c022017 data-v-4d3dfa27><div class="footer-right-wrap" data-v-6c022017><p data-v-6c022017>Персональный блог человека, разработчика и музыканта.</p></div></footer></main><div class="global-ui"></div></div>
    <script src="/assets/js/app.9a3be13b.js" defer></script><script src="/assets/js/6.6d8d87b4.js" defer></script><script src="/assets/js/51.1210696b.js" defer></script>
  </body>
</html>
